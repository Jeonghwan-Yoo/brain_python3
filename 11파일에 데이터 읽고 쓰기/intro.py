'''
11.1 열라, 읽으라(쓰라), 닫으라
애플리케이션이 디스크 같은 하드웨어를 직접 제어해 파일에 접근하는 경우는 거의 없다.
운영체제가 파일관리 업무를 담당하고 있기 때문에 애플리케이션이 운영체제에게
API 함수를 통해 파일 처리를 의뢰하면 운영체제가 요청한 업무를 수행해주고,
그 결과를 애플리케이션에게 돌려줍니다.

파일 업무를 의뢰하는 과정
파일 열기 -> 파일 읽기/쓰기 -> 파일 닫기

열어놓은 파일을 닫지 않으면 자원 누수가 발생하고, 느려지고 다른 동작을 방해할 수도 있다.
파일 열기:file=open()
파일 읽기/쓰기:file.read()/file.write()
파일 닫기:file.close()
open() 통해 연 파일이 이진(Binary)파일이 아니라 텍스트 파일인 경우 더 다양한 메소드 제공.
write.py
read.py

11.1 자원 누수 방지를 돕는 with~as
open()함수와 함께 with~as를 사용하면 명시적으로 close()를 호출 안해도 항상 닫힙니다.
with open(파일이름) as 파일객체: #파일객체=open(파일이름). close()안해도 된다.
    #코드블록
    #이곳에서 읽거나 쓰기를 한 후 그냥 코드를 빠져나가면 됩니다.

11.1.2 with문의 비밀:컨텍스트 매니저(Context Manager)
아무 함수나 with절에 오는게 아니라 컨텍스트 매니저를 제공하는 함수여야 사용 가능.
컨텍스트 매니저는 __enter__()메소드와 __exit__()메소드를 구현하고 있는 객체입니다.
with문은 컨텍스트 매니저를 획득한 후 코드블록의 실행을 시작할 때
컨텍스트 매니저의 __enter__()를 호출하고, 끝날 때 __exit__()를 호출합니다.
__exit__()에 자원 해제 코드를 구현해 놓으면 안전하게 처리할 수 있게 됩니다.
with open('text.txt', 'r') as file: #__enter__()호출
    s=file.read()
    print(s) #__exit__()호출
open2.py

훨씬 간편하게 구할 수 있는 방법은 @contextmanager데코레이터를 이용하는 방법
데코레이터는 __call__()메소드를 구현하는 클래스.
@contextmanager __call__()은 물론이고, 컨텍스트 매니저 규약을 준수하는 데 필요한
__enter__()메소드와 __exit__()메소드를 모두 갖추고 있습니다.
함수를 하나 만들고 데코레이터로 수식하면 구현이 마무리.
from contextlib import contextmanager #contextlib모듈로부터 contextmanager를 반입

@contextmanager @함수 수식
def 함수이름():
    #자원 획득
    try:
        yield 자원 @yield문을 통해 자원 반환, with코드블록이 시작될 때 실행됨.
    finally:
        #자원 해제 #with문이 종료될 때 실행.
여기서 중요한 점은 3가지
1)try~finally블록
2)try블록에서는 yield문을 통해 자원을 반환.
yield는 자신의 매개변수로 넘겨진 자원을 반환한 뒤 임시적으로 현재 함수의 실행을 중지.
정지된 함수는 with문의 코드블록이 실행이 끝날 때 다시 실행.
3)finally 블록에서 획득한 자원을 해제합니다.
즉, 이 함수는 try블록이 __enter__(), finally블록이 __exit__()메소드 역할을 수행합니다.
open3.py

11.1.3 open() 함수 다시 보기
컴퓨터가 다루는 모든 파일은 바이너리 파일입니다.
바이너리 파일 중에서 텍스트 데이터만 기록하고 있는 파일을 텍스트 파일이라고 합니다.
open()은 매개변수에 따라 결정할 수 있습니다.
open()은 8개의 매개변수를 받아들이며, 하나의 필수 매개변수와 일곱 개의 선택 매개변수.
open()함수의 반환값은 파일 객체.
open(file, mode='r', buffering=-1, encoding=None, errors=None,
    newline=None, closefd=True, opener=None)

file에는 보통 실제 파일의 경로를 나타내는 문자열을 넘기지만, 이미 생성해 놓은 파일 객체의
파일 기술자(fileno)를 넘겨 사용하기도 합니다.
파일 기술자(File Descriptor)는 운영체제에서 파일에 대해 애플리케이션에게 할당한 번호값.

mode에 따라 쓰기, 읽기, 텍스트인지 결정
'r':읽기용으로 열기(기본값)
'w':쓰기용으로 열기. 같은 경로에 파일이 존재하면 파일 내용을 비움.
'x':배타적 생성모드. 파일이 존재하면 IOError 예외를 일으킴.
'a':쓰기용으로 열기. 같은 경로에 파일이 존재하면 기존 내용에 덧붙임.
'b':바이너리 모드
't':텍스트 모드(기본값)
'+':읽기/쓰기용으로 파일 읽기
따라서 open('test.txt','rt')=open('test.txt','r')=open('test.txt','t')=open('test.txt')
표에 나타난 문자들은 서로 조합해서 사용 가능. 'wb', 'rt'이런식으로.

buffering은 버퍼링 정책을 지정하는데 사용.
0을 입력하면 파일 입출력시에 버퍼링을 수행하지 않으며(바이너리 모드에서만 사용 가능)
1을 입력하면 개행 문자(역슬래쉬n)를 만날 때까지 버퍼링하는 라인 버퍼링을 수행(텍스트만)
임의의 값으로 크기를 직접 지정하고 싶을 때는 1보다 큰수를 입력
아무 값도 넣지 않은 경우에는 시스템에서 지정해둔 기본값.

encoding은 텍스트 모드에서만 사용 가능. 매우 중요.

errors는 텍스트 모드에서만 사용가능.
인코딩과 디코딩을 수행할 때 발생하는 에러가 어떻게 처리될지를 지정하는 문자열. 공란가능.
'strict':인코딩 에러가 발생할 때 ValueError 예외를 일으킴. None과 똑같은 효과
'ignore':에러를 무시.
'replace':기형적인 데이터가 있는 곳에 대체 문자('?')를 삽입.
'surrogateescape':U+DC80~U+DCFF사이에 있는 유니코드 사용자 자유영역(PUA)의
잘못된 바이트를 코드 포인트로 나타냅니다
'xmlcharrefreplace':파일에 기록하려는 텍스트 안에 지정된 인코딩(문자 읽/쓰는방식)에서
지원되지 않는 문자를 &#NNN꼴의 XML 문자참조로 바꿔서 기록하는 옵션. 파일을 쓸 때만적용.
'backslashreplace':파일에 텍스트를 기록할 때만. 현재 인코딩에서 지원되지 않는 문자를
역슬래시로 시작되는 이스케이프 시퀀스로 바꿔서 기록합니다.

newline은 파일을 읽고 쓸 때 줄바꿈을 어떻게 처리할지를 나타냅니다.
텍스트 모드에서만 사용할 수 있습니다. 
None, '', '역슬래시n', '역슬래시r', '역슬래시r역슬래시n' 중 하나를 입력.
1)파일을 읽을 때:None이면, '역슬래시n', '역슬래시r', '역슬래시r역슬래시n'를 모두
개행 문자로 간주. 그리고 개행 문자를 '역슬래시n'으로 변환하여 읽기 메소드에게 반환.
''으로 설정되어 있으면 None과 동일하게 동작하지만, 개행 문자의 변환을 수행하진 않음.
'역슬래시n'은 '역슬래시n'으로, '역슬래시r역슬래시n'은 '역슬래시r역슬래시n'으로 그대로.
이 외에 '역슬래시n', '역슬래시r', '역슬래시r역슬래시n' 중 하나를 입력하면
입력한 문자만을 개행 문자로 간주. 나머지는 취급하지 않습니다.
2)파일을 쓸 때:None이면 '역슬래시n', '역슬래시r', '역슬래시r역슬래시n'등 어떤 개행
문자를 파일에 쓰려고 해도 시스템 기본 개행문자(os.linesep)로 변환되어 기록됨.
''또는 '역슬래시n'을 지정할 경우에는 어떤 변환도 수행하지 않습니다.
'역슬래시r', '역슬래시r역슬래시n'등이 지정되면 모든 개행 문자가 지정한 
개행 문자로 변환되어 기록

closefd는 첫 번째 매개변수 file에 파일의 경로가 아닌 파일 기술자가 입력됐을 때만 사용.
file매개변수에 파일 기술자를 입력하고 closefd 매개변수에는 False를 입력하면
파일이 닫히더라도 파일 기술자를 계속 열어둔 상태로 유지.

opener는 파일을 여는 함수를 직접 구현하고 싶을 때 이용.
opener에 구현한 함수 또는 호출 가능 객체(__call__()메소드를 구현하는 객체)를 넘기면 됨.
opener에 넘기는 함수/호출가능 객체는 반드시 파일 기술자를 반환해야 합니다.

11.2 텍스트 파일 읽기/쓰기
11.2.1 문자열을 담은 리스트를 파일에 쓰는 writelines() 메소드
writelist.py

writelines()는 같은 기능을 한결 더 수월하게 구현할 수 있도록.
writelines()는 문자열을 요소로 가지는 순서열 객체를 매개변수로 입력받아
해당 순서열 객체의 내용을 모두 파일에 기록합니다.
writelines.py
>type movie_quotes.txt #type은 윈도우에서 제공하는 명령어. cat과 비슷.
we~

11.2.2 줄 단위로 텍스트를 읽는 readline()과 readlines() 메소드
readline()은 파일로부터 텍스트를 한 줄씩만 읽어옵니다.
'한 줄'의 기준은 개행 문자가 됩니다.
open()의 newline을 건들지 않았다면 '역슬n', '역슬r', '역슬r역슬n' 모두 개행문자
앞 개행 문자 이후부터 그 다음 개행문자까지를 한 줄로 판단.

readlines()는 파일로부터 문자열 리스트를 읽어 들입니다.
리스트의 각 요소는 개행문자로 구분된 한 줄의 텍스트입니다.

readline.py
readline()함수는 개행문자까지 읽어 들입니다.
print()는 매개변수로 입력된 문자열 뒤에 줄바꿈 문자를 출력하므로,
end 매개변수를 ''로 지정하지 않는다면 줄바꿈이 두 번씩 출력.

파일의 모든 텍스트를 읽어들여 개행 문자 기준으로 요소를 삼는 리스트를 만들어 반환.
readlines.py

11.2.3 문자 집합과 인코딩
프로그램이 가능한 컴퓨터는 훨씬전에 배비지가 개발한 해석기관입니다.
해석기관은 기계식 범용 컴퓨터로, 에이다 러브레이스가 프로그램을 만들었습니다.
악보를 기호로 표현할 수 있다면 텍스트를 기호로 표현할 수 있다.
그래서 문자 집합(Character set)이 나옵니다.
ASCII는 1960년대에 제정된 문자 집합.
ASCII는 7비트만을 이용하여 음이 아닌 수에 문자 집합 내의 문자를 할당.
하지만 다른나라 문자에서는 ASCII로 표현할 수 없었습니다.
새로운 국제 표준 ISO/IEC 8859-1입니다. 8비트. 후에 8859-N이 제정.
아시아는 8비트에도 맞지 않았습니다.
DBCS(Double-Byte Character Set) 2바이트를 활용해서 문자 집합을 구성하는 법.
DBCS는 ASCII호환을 위해 최상위 비트가 0이면 ASCII 1이면 DBCS로 인식.
이런 방식으로 한글문자는 KS X 1001, EUC-KR, CP949 등이 생김.
(EUC-KR은 ASCII에서 '역슬래시'기호를 '원화'로 바꾼 영문자 표준 합집합)
하지만, 운영체제가 기본적으로 제공하는 문자 집합과 다른 문자 집합을 이용하면 깨집니다.
소프트웨어 회사들이 힘을 모아 유니코드협회를 만들고 유니코드(Unicode)를 제정.
단 2바이트로 현대의 모든 문자와 기호를 표현할 수 있다는 사실로 할당.
문자에 부여되는 번호를 코드 포인트(Code Point).
코드포인트는 'U+'뒤에 2바이트의 수를 16진수로 표현하여 붙여 표시합니다.
U+0000부터 U+007F까지를 ASCII와 동일하게 맞추고 그 뒷번호부터 각구의 문자를 할당.
누락된 현대 문자와 기호를 추가적으로 할당하고 고대것을 추가하자 2바이트를 넘김.
유니코드를 인코딩하는 방법을 정의하는 표준이 필요해졌습니다.
UTF는 변환 인코딩 형식(Unicode Transformation Format)
가장 많이 사용하는 것은 UTF-8.
UTF-8은 코드포인트의 크기에 따라 1바이트에서부터 4바이트까지 가변폭으로 인코딩.
ASCII와도 완벽하게 호환되서 UTF-8 인코딩 문서는 유니코드를 알지 못하는 시스템에도 적용가능.

utf8_write.py
utf8_read.py

한글버전 윈도우8/10 명령 프롬프트의 기본 인코딩은 CP949
스페인어 같은게 출력안되서 제어판에서 변경하는 등 귀찮아짐.

ascii_read.py

11.3 바이너리 파일 다루기
123은 정수형식 '123'은 문자열 형식.
'123'은 텍스트 파일에 저장할 수 있지만, 123을 그대로 텍스트 파일에 저장할 수 없다.
123이 메모리에 저장되어 있는 구조와 텍스트 파일의 저장 구조가 다르기 때문에.
바이너리 파일은 메모리에 저장되어 있는 내용을 그대로 저장하고자 할 때 유용.

파이썬에서는 struct모듈의 도움 없이는 바이너리 파일을 다루기 어렵습니다.
struct 모듈은 일반 데이터 형식과 bytes 형식 사이의 변환을 수행하는 함수들을 가진다.
>>>import struct
#pack()은 첫 번째 매개변수 'i'에 따라 4바이트 크기의 bytes 객체 packed를
#준비하고 두 번째 매개변수를 bytes에 복사해서 넣습니다.
>>>packed=struct.pack('i',123)
>>>for b in packed:
    print(b) #bytes 객체 packed의 각 바이트에 있는 내용을 출력합니다.
123
0
0
0
#unpack()은 튜플 형식을 반환.
>>>unpacked=struct.unpack('i',packed)
>>>unpacked
(123,)
>>>type(unpacked)
<class 'tuple'>
pack()은 일반데이터를 bytes형식으로 변환하는 기능.
unpack()는 bytes형식을 튜플 형식으로 변환하는 기능.
struct.pack(fmt,v1,v2,...) #데이터->bytes
struct.unpack(fmt,buffer) #bytes->튜플(데이터)

공통점은 첫 번째 매개변수가 이진 데이터의 구조를 나타내는 형식 문자열(Format String)
fmt가 형식 문자열.
=2f12si
=는 바이트 순서, 뒤에는 데이터 구조 및 형식, 크기.
문자열을 'i'로만 지정했는데 이것은 
'바이트 순서:시스템 기본값, 데이터 구조:4바이트 크기의 정수형식 1개'로 데이터 변환한다 것.

바이트 순서는 CPU나 플랫폼마다 바이트를 정렬하는 순서가 다르기 때문에 중요함.
x86계열은 데이터의 하위바이트부터 메모리에 배열(역순)하는 리틀 엔디안(Little Endian) 방식
ARM이나 PowerPC는 상위바이트부터 메모리에 배열(순)하는 빅 엔디안(Big Endian) 방식
  바이트 순서                   크기              바이트 정렬
@ 시스템 바이트 순서를 따릅니다. 시스템을 따릅니다. 시스템을 따릅니다.
= 시스템 바이트 순서를 따릅니다. 표준을 따릅니다.   수행 안함
< 리틀 엔디안                   표준을 따릅니다.   수행 안함
> 빅 엔디안                     표준을 따릅니다.   수행 안함
! 네트워크 바이트 순서(빅 엔디안) 표준을 따릅니다.   수행 안함
지정하지 않는 경우에는 '@'를 따릅니다.

바이트 정렬은 컴퓨터는 4바이트나 8바이트 등으로 묶음 처리를 하려는 경향.
1바이트, 4바이트라면 8바이트 크기로 다룸.
형식 문자열에 '@'가 들어오지 않는다면 바이트 정렬을 수행하지 않도록 구현.

데이터 구조를 정의하는 형식 문자.
분류        문자 파이썬자료형   C자료형              크기
정수형      b    integer       signed char         1
정수형      B    integer       unsigned char       1
정수형      ?    bool          _Bool               1
정수형      h    integer       short               2
정수형      H    integer       unsigned short      2
정수형      i    integer       int                 4
정수형      I    integer       unsigned int        4
정수형      l    integer       long                4
정수형      L    integer       unsigned long       4
정수형      q    integer       long long           8
정수형      Q    integer       unsigned long long  8
정수형      n    integer       ssize_t      
정수형      N    integer       size_t      
부동 소수형 f    float          float              4
부동 소수형 d    float          double             8
bytes      s    bytes          char[]             
bytes      p    bytes          char[]             
bytes      c    크기1인 bytes   char               1
기타       x    no value       패팅바이트(정렬용)
기타       P    integer        void*
'2f12si'는 4바이트 부동 소수형2개, 크기가 12인 bytes, 4바이트 정수형 1개인 자료구조.
>>>import struct
>>>packed=struct.pack('f',123.456)
>>>unpacked=struct.unpack('f',packed)
>>>unpacked
(123.45600128173828,) #튜플
>>>import
#str.encode()/str.decode()는 매개변수를 생략하면 utf-8을 기본으로 지정.
>>>packed=struct.pack('12s','대한민국'.encode())
>>>unpacked=struct.unpack('12s',packed)
>>>unpacked[0].decode()
'대한민국'
>>>import struct
#*연산자는 튜플이나 리스트의 요소를 하나씩 분리해서 매개변수로 입력해줌.
>>>packed=struct.pack('2d2i', *(123.456, 987.765, 123, 456))
>>>unpacked=struct.unpack('2d2i',packed)
>>>unpacked
(123.456, 987.765, 123, 456)

튜플의 리스트를 이진 파일에 기록하고 다시 읽어 들이는 일
binary_write.py
binary_read.py

'''